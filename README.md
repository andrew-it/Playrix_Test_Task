# Playrix Test Task

## Задание "Тир"

Видео на YouTube: [https://youtu.be/fx2Ld4Il0gE](https://youtu.be/fx2Ld4Il0gE)

### Особенности

* Объекты "живут" в 3Д, то есть вся логика, баллистика, коллизии простчитываются в 3Д пространстве, и уже потом отображаются в 2Д;
* Рикошеты от стен;

### Игровой процесс

* При запуске приложения, создаются N мешеней, которые необходимо поразить за отведённое количество времени;
* Стрельба осуществляется нажатием левой кнопки мыши;
* Рестарт игры возможен как во время игры, так и при её завершении. Рестарт назначен на кнопку `r` ;

### Что можно было бы добавить

* Хитпоинты у мишеней;
* Несколько видов вооружения, в том числе и метатеьного, а-ля гранаты;
* Для этого необходимо будет реализовать воздействие гравитации на снаряды;
* HUD, вид оружия (сейчас пули появляются в воздухе);
* Чтение конфигурационного файла при запуске (сейчас недоступно, все константы необходимо менять в `Constants.h`);

### Ответы на вопросы

* Затраченное время: около 20 часов;
* Интереснее было делать логику игры;
* Архитектура описана ниже;
* Как таковых проблем не возникало -- лишь мелкие сложности (описал ниже);

### Архитектура

Ну, во первых хочется сказать, что никакими MVP, MVC & MVVM здесь и не пахнет -- было желание соответствовать одному из вышеописанных паттернов в самом начале, но я банально пожалел время и сделал всё по-простому: модель, отображение и контроллер игры расположены в соответствующем виджете `GameObjectsWidget`. Витжет `GuiWidget` служит для отображения HUD'a, которого ещё нет. Витжет `DebugWidget` служит для отображения координат мыши и данных FPS и расхода памяти. Так как `DebugWidget` служит исключительно для отладки, то существует переменная `IS_DEBUG`, которая позволяет отключать изображение информации (к сожалению, одной лишь переменной не отключить весь виджет в силу архитектуры движка).

Файлы исходного кода разделены по 4 папкам:

* `Other` --- Здесь расположены необходимые интерфейсы, реализации классов точки, вектора и Bounding Box'a, которые используются в проекте.
* `General` --- Здесь расположена точка входа программы.
* `GameObjects` --- Здесь расположен абстрактный класс `IGameObject` и дочерние от него `Target` и `Bullet`;
* `Widgets` --- Здесь расположены вышеописанные виджеты;

Пробежимся по каждому из мною написанных/изменённых классов и файлов:

Дата классы:

* `FPoint3` -- Стандартная трёхмерная точка с координатами из вещесественных чисел;
* `FVector3` -- Вещественных трёхмерный вектор, используется для задания направления полёта пули;
* `BoundinBox` -- Используется для задания объёмов и координаты для объетков типа `IGameObject`. Агрегирует `FPoint3`.

Интерфейсы:

* `IProjectile` -- Интерфейс, агрегирующий `FVector3`. Может быть расширен интерфейсом функции для учёта силы тяжести и соответствующими параметрами;
* `IUpdatable` -- Интерфейс, имеющий функцию `Update(float)`, по функционалу повторяющую такую же в движке;
* `IDrawable` -- То же самое, только для функции `Draw()` из движка;
* `IInitable` -- Интерфейс для единственной функции `Init()`, которая служит для инициализации объекта класса, наследующего этот интерфейс;

Константы:

* `Constants` -- Содержит все необходимые константы (в т.ч. вышеупомянутую `IS_DEBUG`), до которых хорошо бы иметь доступ из любой части проекта;

Игровые объекты:

* `IGameObject` -- Абстрактный класс и базовый класс для `Target` и `Bullet`. Реализует общий метод `Draw()`, наследуется от всех интерфейсов и агрегирует `BoundinBox` для хранения позиции и размеров объекта;
* `Bullet` -- Реализует функцию `Update(float)`, `collisionWithWalls()`, которая используется для просчёта столкновений со стенами и расчёта рикошета;
* `Target` -- Также реализует `Update(float)` и содержит функцию случайной генерации сплайна;

Функции виджета `GameObjectsWidget`:

* `DrawTargets()` и `DrawBullets()` -- Функции, которые отрисовывают мишени и пули, находящиеся в списках  `list_of_targets` и `list_of_bullets` соответственно. Если взглянуть на эти две функции, то будет понятно, что их необходимо обобщить, но, поскольку там используются "умные указатели" `std::shared_ptr`, то с этим возникли некоторые сложности, и было решено просто написать две практически одинаковые функции.
* `UpdateTargets(float)` `UpdateBullets(float)` -- Рассчитывают местоположение мишеней и пуль соответственно. По поводу обобщения -- та же самая ситуация, что и с вышеописанными;
* `checkTargets()` -- Рассчитывает и регистрирует попадания пуль в мишень и удаляет мишени, в которые попали (используется аттрибут `to_delete`);
* `checkBullets()` -- Удаляет пули, которые попали в мешени;
* `Draw()` -- Помимо вызова функций `DrawTargets()` и `DrawBullets()`, также выводит текст с количеством очков и оставшимся временем;
* `Update(float)` -- Вызывает `UpdateTargets(float)` `UpdateBullets(float)`, а так же осуществляет проверку на условия конца игры;
* `showGameOver()` -- Выводит текст в конце игры.
* `MouseDown(IPoint)` -- Создаёт объект класса `Bullet` и определяет вектор полёта пули в зависимости от положения мыши;
* `restartGame()` -- Очищает `list_of_targets` и `list_of_bullets` и заново инициализирует игровые параметры;
* `CharPressed(int)` -- Запускает `restartGame()` в зависимости от нажатой клавиши;

### Проблемы

Проблем в игре вагон и маленькая тележка. Начнём от более критических к менее:

* На текстурирование трёхмерной комнаты не хватило времени, поэтому ощутить её масштабы можно лишь "наощубь", используя такую фичу игры как рикошеты;
* Из-за вышеописанной проблемы, у игрока не возникает ощущения глубины сцены, из-за чего непонятно как целиться в мишени;
* Видимо, некоторые сплайны имеют совпадающие точки, либо же некоторые мишени просто не орисосвываются, из-за чего можно наблюдать несовпадение в колчестве очков и мишеней на экране;
* Эффекты попадания в мишень не отображаются;
* Не удалось установить кастомные шрифты;